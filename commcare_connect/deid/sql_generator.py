from django.core.exceptions import FieldDoesNotExist

from commcare_connect.deid.config import STRATEGY_DROP_FIELD, AnonymizationConfig

# Define a default name for the read-only role
DEFAULT_READONLY_ROLE_NAME = "ccc_data_analyst"
DEFAULT_EXPECTED_DB_NAME = "ccc_analytics"


def generate_anonymization_sql(
    anonymization_configs: list[AnonymizationConfig],
    readonly_role_name: str = DEFAULT_READONLY_ROLE_NAME,
    expected_db_name: str = DEFAULT_EXPECTED_DB_NAME,
) -> list[str]:
    """
    Generates SQL statements to anonymize the database based on the provided configurations.

    This function creates SQL for:
    0. Validating that the script is run against the expected database name.
    1. Dropping all views in the 'public' schema to prevent dependency errors.
    2. Dropping specified columns from tables based on the configuration.
    3. Creating/configuring a read-only PostgreSQL role with access to the 'public' schema.

    It uses Django's model metadata to determine database table and column names.
    The generated SQL is wrapped in a single transaction.
    """
    sql_statements = []
    sql_statements.append("-- SQL De-identification Script --")
    sql_statements.append("-- Generated by CommCare Connect deidentify_database command --")
    sql_statements.append("-- Ensure this script is run only on a non-production, copied database! --")
    sql_statements.append("\nBEGIN;")  # Start a transaction

    # Step 0: Validate current database name
    sql_statements.append(f"\n-- Step 0: Validate current database name is '{expected_db_name}' --")
    sql_statements.append(
        f"""
DO
$$
DECLARE
    expected_db_name_const TEXT := '{expected_db_name}';
    current_db_name TEXT := current_database();
BEGIN
    IF current_db_name <> expected_db_name_const THEN
        RAISE EXCEPTION 'WRONG DATABASE: Script is connected to "%", but expected "%" (defined in script). Aborting.', current_db_name, expected_db_name_const;
    END IF;
    RAISE NOTICE 'Correct database: Script is connected to "%" and matches expected name "%" (defined in script). Proceeding.', current_db_name, expected_db_name_const;
END
$$;
"""  # noqa: E501
    )
    sql_statements.append("-- End of database name validation --")

    # Step 1: Drop all views in the public schema
    sql_statements.append("\n-- Step 1: Drop all views in the public schema to avoid dependencies --")
    sql_statements.append(
        """
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT viewname FROM pg_catalog.pg_views WHERE schemaname = 'public') LOOP
        EXECUTE 'DROP VIEW IF EXISTS public."' || r.viewname || '" CASCADE;';
    END LOOP;
END $$;
"""
    )
    sql_statements.append("-- End of dropping all views in public schema --")

    # Step 2: Drop specified columns from tables
    sql_statements.append("\n-- Step 2: Drop specified columns from tables --")
    processed_tables = set()  # To keep track of tables for which comments have been added
    for config in anonymization_configs:
        model_class = config.model
        table_name = model_class._meta.db_table
        if table_name not in processed_tables:
            sql_statements.append(f'\n-- Anonymizing table: "{table_name}" (Model: {model_class.__name__})')
            processed_tables.add(table_name)

        for field_config in config.fields:
            model_field_name = field_config.field_name
            try:
                db_column_name = model_class._meta.get_field(model_field_name).column
                if field_config.anonymization_strategy == STRATEGY_DROP_FIELD:
                    sql_statements.append(f'ALTER TABLE "{table_name}" DROP COLUMN IF EXISTS "{db_column_name}";')
                else:
                    sql_statements.append(
                        f"-- SKIPPING: Unknown or unsupported anonymization strategy "
                        f"'{field_config.anonymization_strategy}' for field '{model_field_name}' "
                        f'(column "{db_column_name}") in table "{table_name}"'
                    )
            except FieldDoesNotExist:
                sql_statements.append(
                    f"-- WARNING: Field '{model_field_name}' not found in model '{model_class.__name__}' "
                    f'(table "{table_name}"). Cannot determine column name. Skipping.'
                )

    # Step 3: Create or update a read-only role
    sql_statements.append(f"\n-- Step 3: Configure read-only role: '{readonly_role_name}' --")
    sql_statements.append("-- Note: The password for this role is NOT set by this script. ")
    sql_statements.append(
        "-- Please set a strong password manually using: "
        f"ALTER ROLE \"{readonly_role_name}\" PASSWORD 'your_password';"
    )

    # DO block for role creation (if not exists) or alteration
    sql_statements.append(
        f"""
DO
$$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '{readonly_role_name}') THEN
        CREATE ROLE "{readonly_role_name}" WITH LOGIN PASSWORD NULL;
    ELSE
        ALTER ROLE "{readonly_role_name}" WITH LOGIN PASSWORD NULL;
    END IF;
END
$$;
"""
    )

    # DO block for granting privileges to the role
    sql_statements.append("-- Granting privileges using a DO block for robustness")
    sql_statements.append(
        f"""DO
$$
DECLARE
  role_to_grant TEXT := '{readonly_role_name}';
  db_name TEXT := current_database(); -- Get current database name
BEGIN
  EXECUTE format('GRANT CONNECT ON DATABASE %I TO %I;', db_name, role_to_grant);
  EXECUTE format('GRANT USAGE ON SCHEMA public TO %I;', role_to_grant);
  EXECUTE format('GRANT SELECT ON ALL TABLES IN SCHEMA public TO %I;', role_to_grant);
  EXECUTE format('ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO %I;', role_to_grant);
END
$$;
"""
    )
    sql_statements.append(f"-- End of read-only role configuration for '{readonly_role_name}' --")

    sql_statements.append("\nCOMMIT;")  # End transaction
    sql_statements.append("-- End of De-identification Script --")
    return sql_statements
