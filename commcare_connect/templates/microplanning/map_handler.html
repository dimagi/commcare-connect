<script>
    document.addEventListener("alpine:init", () => {
        Alpine.data("mapController", () => ({
            map: null,
            selectedAreas: new Set(),

            init() {
                this.$nextTick(() => {
                    this.initializeMap();
                });
            },

            async initializeMap() {
                const accessToken = '{{ mapbox_api_key|escapejs }}';
                const org_slug = '{{ request.org.slug|escapejs }}';
                const opp_id = '{{ request.opportunity.opportunity_id|escapejs }}';
                const url = `/a/${org_slug}/microplanning/${opp_id}/workareas_geojson/`;

                if (!MapboxUtils.setAccessToken(accessToken)) return;

                this.map = MapboxUtils.createMap({
                    container: 'map',
                    style: 'mapbox://styles/mapbox/standard',
                    projection: 'globe',
                    zoom: 5,
                    center: [8.675, 9.082]
                });

                MapboxUtils.addNavigation(this.map, 'top-left');
                MapboxUtils.addDrawControls(this.map);

                const $mapContainer = document.getElementById('map');
                const observer = new ResizeObserver(() => this.map.resize());
                observer.observe($mapContainer);

                await new Promise((resolve) => {
                    this.map.once('style.load', resolve);
                });

                const response = await fetch(url);
                if (!response.ok) throw new Error("Failed to fetch GeoJSON");
                const data = await response.json();

                // Assign color by group_id, extend bounds — single pass
                const palette = ["#4A90D9", "#D63B3B", "#9B6DC5", "#3DAA4E", "#E8820C"];
                const groupColors = {};
                let idx = 0;
                const bounds = new mapboxgl.LngLatBounds();

                data.features.forEach(f => {
                    // Color by group_id (falls back to assigned_user_id when groups have users)
                    const gId = f.properties.group_id || f.properties.assigned_user_id || 0;
                    if (!groupColors[gId]) {
                        groupColors[gId] = palette[idx % palette.length];
                        idx++;
                    }
                    f.properties.color = groupColors[gId];

                    // Extend bounds
                    f.geometry.coordinates[0].forEach(([lng, lat]) => bounds.extend([lng, lat]));
                });

                // Work areas source
                this.map.addSource('workareas', {
                    type: 'geojson',
                    data,
                    promoteId: 'id' // allows feature-state (selected) to work by id
                });

                // Fill — color by group, opacity by status
                this.map.addLayer({
                    id: 'workareas-fill',
                    type: 'fill',
                    source: 'workareas',
                    paint: {
                        'fill-color': [
                            'case',
                            ['boolean', ['feature-state', 'hovered'], false],
                            '#ffffff',        // briefly flash white on hover
                            ['get', 'color']  // normal FLW color
                        ],
                        'fill-opacity': [
                            'match', ['get', 'status'],
                            'EXPECTED_VISIT_REACHED', 1.0,
                            'VISITED', 0.85,
                            'NOT_VISITED', 0.65,
                            'UNASSIGNED', 0.55,
                            'NOT_STARTED', 0.50,
                            'EXCLUDED', 0.45,
                            'INACCESSIBLE', 0.40,
                            'REQUEST_FOR_INACCESSIBLE', 0.35,
                            0.6
                        ]
                    }
                });

                // Thin white grid lines
                this.map.addLayer({
                    id: 'workareas-outline',
                    type: 'line',
                    source: 'workareas',
                    paint: {
                        'line-color': '#ffffff',
                        'line-width': 0.5,
                        'line-opacity': 0.4
                    }
                });

                // Yellow selection outline — hidden until selected
                this.map.addLayer({
                    id: 'workareas-selected',
                    type: 'line',
                    source: 'workareas',
                    paint: {
                        'line-color': '#ffff00',
                        'line-width': 3,
                        'line-opacity': [
                            'case',
                            ['boolean', ['feature-state', 'selected'], false],
                            1,   // visible when selected
                            0    // hidden when not selected
                        ]
                    }
                });

                // Group boundary outlines — computed by PostGIS on backend
                if (data.group_features?.length) {
                    this.map.addSource('workarea-groups', {
                        type: 'geojson',
                        data: { type: "FeatureCollection", features: data.group_features }
                    });

                    this.map.addLayer({
                        id: 'workarea-groups-outline',
                        type: 'line',
                        source: 'workarea-groups',
                        paint: {
                            'line-color': '#000000',
                            'line-width': 3,
                            'line-opacity': 0.4
                        }
                    });
                }

                // Fit map to data
                if (!bounds.isEmpty()) {
                    this.map.fitBounds(bounds, { padding: 40 });
                }

                // Click to select/deselect
                this.map.on('click', 'workareas-fill', (e) => {
                    const id = e.features[0].properties.id;
                    if (this.selectedAreas.has(id)) {
                        this.selectedAreas.delete(id);
                    } else {
                        this.selectedAreas.add(id);
                    }
                    this.map.setFeatureState(
                        { source: 'workareas', id },
                        { selected: this.selectedAreas.has(id) }
                    );
                });


                let hoveredId = null;
                this.map.on('mousemove', 'workareas-fill', (e) => {
                    this.map.getCanvasContainer().style.cursor = 'pointer';
                    const newId = e.features[0].properties.id;
                    if (newId !== hoveredId) {
                        if (hoveredId !== null) {
                            this.map.setFeatureState({ source: 'workareas', id: hoveredId }, { hovered: false });
                        }
                        hoveredId = newId;
                        this.map.setFeatureState({ source: 'workareas', id: hoveredId }, { hovered: true });
                    }
                });
                this.map.on('mouseleave', 'workareas-fill', () => {
                    this.map.getCanvasContainer().style.cursor = '';
                    if (hoveredId !== null) {
                        this.map.setFeatureState({ source: 'workareas', id: hoveredId }, { hovered: false });
                        hoveredId = null;
                    }
                });
            }
        }));
    });
</script>
